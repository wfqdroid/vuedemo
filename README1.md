### vuex简版：
>  Vuex官方文档所说的，如果应用不够大，为避免代码繁琐冗余，最好不要使用它。
      那么有没有什么办法达到一个"简易版"的vuex吗？这里用到了一个api,Observable
      
### 长列表优化：
> 我们应该都知道vue会通过object.defineProperty对数据进行劫持，来实现视图响应数据的变化，
然而有些时候我们的组件就是纯粹的数据展示，不会有任何改变，我们就不需要vue来劫持我们的数据，
在大量数据展示的情况下，这能够很明显的减少组件初始化的时间，那如何禁止vue劫持我们的数据呢？
可以通过object.freeze方法来冻结一个对象，一旦被冻结的对象就再也不能被修改了。这里冻结的只是值，意思是
直接修改值的话是失败的，但是引用是存在的，如果想改变值的话，直接拿一个新对象父赋值即可
  

### 组件
> 首先记住一条结论：一个组件，无论多复杂，都是由三部分组成：prop,event,slot,这三个构成了vue组件的API
* 属性prop
> 写通用组件的时候最好用对象的写法，这样可以针对每个属性设置类型，默认值或者自定义校验属性的值
* 自定义事件event
>  这里设计到一个API，emit,中文是发射的意思，这里我们理解成触发。在子组件中我们通过this.$emit('clickName',event)
来触发事件，组父组件中，我们使用@clickName来监听子组件触发的事件。
这里有一点需要注意，直接在父级声明也是可以的，如果我们使用@clickName相当于是子组件触发的事件，也就是自定义事件click，
而非原生事件，所以如果在父组件直接写@click是监听不到的，但是，使用element-ui的时候我们是可以在<el-button>上面直接
使用@click的，这个怎么解释？其实我们把自定义事件的名字直接写成click即可，也就是this.$emit('click',event)，这样的话
在父组件中就能直接使用@click,达到统一
* 插槽 slot
> 它可以分发组件的内容，比如：我们自定义的button，想在上面添加一些内容的话买就要使用slot,当要用到多个插槽的时候，
我们就会使用到具名插槽，说白点就是在父组件中由别的内容的时候，要指定插槽的名字，比如：
```$xslt
子组件：
<template>
  <button :class="'w-button-size' + size" :disabled="disabled">
    <slot name="icon"></slot>
    <slot></slot>
  </button>
</template>
父组件：

<w-button>
  <w-icon slot="icon" type="checkmark"></w-icon>
  按钮 1
</w-button>
```
* 组件之间的通信：
使用方式：见@/components/WButton.vue和SimpleComponent
> 如果想在父组件中触发子组件的方法或者是拿到子组件中的属性的话怎么做？
这里会涉及到三个API：ref,$parent,$children,着三个都是直接得到组件的实例，使用后可以直接调用组件的
方法或者访问组件的数据，ref常用，这里不多做介绍，parent通常是在子组件里面拿到父组件的值，children通常是在
父组件里面拿到子组件的实例，但是一个父组件可能会使用多个子组件，this.$children得到的是一个数组，使用children
的一个缺点就是你要明确的知道该页面使用了多少个子组件.但是这种方式在跨组件通信的时候是有弊端的，当组件A和组件B间隔了
数代的时候往往会借助Vuex和bus通信这样的方案







    